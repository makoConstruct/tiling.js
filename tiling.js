// Generated by CoffeeScript 1.8.0
(function() {
  var Component, DetailedPosition, ForSpan, Line, LineForming, Mount, TODO, Tile, afterAnim, afterFade, animationDuration, cardForVars, cardIsForward, cardIsH, cardIsV, cardOpposite, cardSide, cardinalFor, cardinalOrOrdinal, creationColor, elBounds, fadeDuration, forCardinalComponentsOfCordinal, fromCardinal, insertBefore, keysForCard, keysForOrientation, minimumTileSpan, mouseEvRelTo, ordForVars, ordIsDown, ordIsRight, ordinalFor, orientationKeys, prependChild, reflectCordinalHoriz, reflectCordinalVert, removeEl, tileOrLine, timeoutSet, yeildThen,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  elBounds = function(el) {
    var cr;
    cr = el.getBoundingClientRect();
    return {
      x: cr.left + document.body.scrollLeft,
      y: cr.top + document.body.scrollTop,
      w: cr.width,
      h: cr.height
    };
  };

  insertBefore = function(arr, i, nel) {
    var aft, fore;
    fore = arr.slice(0, i);
    fore.push(nel);
    aft = arr.slice(i, arr.length);
    return fore.concat(aft);
  };

  prependChild = function(container, child) {
    return container.insertBefore(child, container.firstChild);
  };

  timeoutSet = function(delay, cb) {
    return setTimeout(cb, delay);
  };

  yeildThen = function(f) {
    return setTimeout(f, 0);
  };

  mouseEvRelTo = function(ev, el) {
    var cr;
    cr = el.getBoundingClientRect();
    return {
      x: ev.pageX - cr.left,
      y: ev.pageY - cr.top
    };
  };

  removeEl = function(el) {
    return el.parentNode.removeChild(el);
  };

  this.tilingjs_version = '1.0';

  orientationKeys = [
    {
      span: 'width',
      Span: 'Width',
      clientSpan: 'clientWidth',
      d: 'x',
      D: 'X',
      rear: 'left',
      front: 'right',
      offset: 'offsetLeft'
    }, {
      span: 'height',
      Span: 'Height',
      clientSpan: 'clientHeight',
      d: 'y',
      D: 'Y',
      rear: 'top',
      front: 'bottom',
      offset: 'offsetTop'
    }
  ];

  keysForCard = function(g) {
    return orientationKeys[(g >> 1) ^ 1];
  };

  keysForOrientation = function(bool) {
    return orientationKeys[+(!bool)];
  };

  cardinalFor = function(x, y, w, h) {
    var a, b, m;
    m = h / w;
    a = y > m * x;
    b = y > h - m * x;
    return ((a ^ b) << 1) | b;
  };

  cardIsH = function(g) {
    return !!(g & 2);
  };

  cardIsV = function(g) {
    return !(g & 2);
  };

  cardIsForward = function(g) {
    return !!(g & 1);
  };

  cardForVars = function(isHoriz, isForward) {
    return (isHoriz << 1) | isForward;
  };

  cardOpposite = function(g) {
    return g ^ 1;
  };

  cardSide = ['top', 'bottom', 'left', 'right'];

  ordinalFor = function(x, y, w, h) {
    return ((y > h / 2) << 1) | (x > w / 2);
  };

  ordIsRight = function(ord) {
    return !!(ord & 1);
  };

  ordIsDown = function(ord) {
    return !!(ord & 2);
  };

  ordForVars = function(isDown, isRight) {
    return (isDown << 1) | isRight;
  };

  cardinalOrOrdinal = function(cordinal, ifCardinal, ifOrdinal) {
    if (cordinal <= 3) {
      return ifCardinal(cordinal);
    } else {
      return ifOrdinal(cordinal & 3);
    }
  };

  forCardinalComponentsOfCordinal = function(cordinal, ifNorth, ifEast, ifSouth, ifWest) {
    switch (cordinal) {
      case 0:
        ifNorth();
        ifWest();
        break;
      case 1:
        ifNorth();
        ifEast();
        break;
      case 2:
        ifSouth();
        ifWest();
        break;
      case 3:
        ifEast();
        ifSouth();
        break;
      case 4:
        ifNorth();
        break;
      case 5:
        ifSouth();
        break;
      case 6:
        ifWest();
        break;
      case 7:
        ifEast();
    }
  };

  fromCardinal = function(cardinal) {
    return cardinal | 4;
  };

  reflectCordinalHoriz = function(cordinal) {
    if ((cordinal & 6) === 4) {
      return cordinal;
    } else {
      return cordinal ^ 1;
    }
  };

  reflectCordinalVert = function(cordinal) {
    if (cordinal >= 6) {
      return cordinal;
    } else {
      switch (cordinal) {
        case 0:
          return 2;
        case 2:
          return 0;
        case 4:
          return 5;
        case 5:
          return 4;
        case 1:
          return 3;
        case 3:
          return 1;
      }
    }
  };

  minimumTileSpan = 10;

  animationDuration = 140;

  fadeDuration = 140;

  creationColor = 'rgb(255,255,255)';

  afterAnim = function(cb) {
    return setTimeout(cb, animationDuration);
  };

  afterFade = function(cb) {
    return setTimeout(cb, fadeDuration);
  };

  tileOrLine = function(component, ifTile, ifLine) {
    if (component.constructor === Line) {
      return ifLine(component);
    } else {
      return ifTile(component);
    }
  };

  this.destructiveFade = function(el) {
    el.style.opacity = 0;
    return afterAnim(function() {
      return el.remove();
    });
  };

  TODO = function() {
    return console.error('feature not implemented');
  };

  this.ShadeGenerator = (function() {
    var colorFor, shuffle;

    shuffle = function(arr) {
      var bf, i, j, _i, _ref;
      for (i = _i = 0, _ref = arr.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        j = i + Math.floor(Math.random() * (arr.length - i));
        bf = arr[i];
        arr[i] = arr[j];
        arr[j] = bf;
      }
    };

    function ShadeGenerator() {
      var darkest, igradation, lightest, ngradations;
      darkest = 17;
      lightest = 68;
      ngradations = 14;
      this.shades = (function() {
        var _i, _results;
        _results = [];
        for (igradation = _i = 0; 0 <= ngradations ? _i <= ngradations : _i >= ngradations; igradation = 0 <= ngradations ? ++_i : --_i) {
          _results.push(Math.round(darkest + igradation * (lightest - darkest) / ngradations));
        }
        return _results;
      })();
      shuffle(this.shades);
      this.shadeCounter = 0;
    }

    ShadeGenerator.prototype.takeShade = function() {
      this.shadeCounter = (this.shadeCounter + 1) % this.shades.length;
      return this.shades[this.shadeCounter];
    };

    colorFor = function(shade) {
      return 'rgb(' + shade + ',' + shade + ',' + shade + ')';
    };

    ShadeGenerator.prototype.takeColor = function() {
      return colorFor(this.takeShade());
    };

    return ShadeGenerator;

  })();

  LineForming = (function() {
    function LineForming(ar) {
      this.ar = ar;
    }

    return LineForming;

  })();

  ForSpan = (function() {
    function ForSpan(ar) {
      this.ar = ar;
    }

    return ForSpan;

  })();

  DetailedPosition = (function() {
    function DetailedPosition(obj) {
      this.obj = obj;
    }

    return DetailedPosition;

  })();

  this.widthBeing = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new ForSpan(args);
  };

  this.upto = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return args;
  };

  this.line = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return new LineForming(args);
  };

  this.position = function(obj) {
    return new DetailedPosition(obj);
  };

  this.mount = function(container, baseLine) {
    return new Mount(container, baseLine);
  };

  Mount = (function() {
    var removeLiftingmask;

    function Mount(configArgs) {
      var listeners, preferenceResizings, prime, rootLineExpression, tbroad, tile, tlong, x, y, _i, _len, _ref;
      if (!configArgs.container) {
        throw new Error('configArgs container is mandatory');
      }
      this.shadegen = new ShadeGenerator();
      this.container = configArgs.container;
      this.container.addEventListener('contextmenu', (function(_this) {
        return function(ev) {
          if (_this.ctrlHeld) {
            return ev.preventDefault();
          }
        };
      })(this));
      this.defaultContentGenerator = configArgs.defaultContentGenerator || (function(_this) {
        return function() {
          return _this.generateNullContent();
        };
      })(this);
      rootLineExpression = configArgs.initial || (line(this.defaultContentGenerator()));
      preferenceResizings = [];
      prime = (function(_this) {
        return function(component, parent, isHoriz, broadOrigin, longOrigin, broadSpan, longSpan) {
          var comp, componentArray, dob, fors, generatedLine, i, ori, originb, otherOri, tile, tl, ww;
          ori = keysForOrientation(isHoriz);
          otherOri = keysForOrientation(!isHoriz);
          switch (component.constructor) {
            case LineForming:
              componentArray = component.ar;
              i = 1;
              originb = longOrigin;
              generatedLine = new Line(parent, isHoriz, broadOrigin, longOrigin, broadSpan, longSpan);
              generatedLine.components = componentArray.map(function(cgen) {
                var nextoriginb, ret, spanb;
                nextoriginb = longOrigin + Math.round(i * longSpan / componentArray.length);
                spanb = nextoriginb - originb;
                ret = prime(cgen, generatedLine, !isHoriz, originb, broadOrigin, spanb, broadSpan);
                i += 1;
                originb = nextoriginb;
                return ret;
              });
              return generatedLine;
            case DetailedPosition:
              dob = component.obj;
              tile = prime(dob.content, parent, isHoriz, broadOrigin, longOrigin, broadSpan, longSpan);
              if (dob.desiredWidth || dob.desiredHeight) {
                preferenceResizings.push({
                  tile: tile,
                  x: dob.desiredWidth,
                  y: dob.desiredHeight
                });
              }
              return tile;
            case ForSpan:
              fors = component.ar;
              ww = _this.container.clientWidth;
              if (ww === 0) {
                console.error('needed the width of container to be set already in order to initialize. No width. Gonna suck.');
              }
              i = 0;
              comp = null;
              while (true) {
                if (fors[i].length === 1) {
                  comp = fors[i][0];
                  break;
                } else if (ww <= fors[i][0]) {
                  comp = fors[i][1];
                  break;
                } else if (i + 1 === fors.length) {
                  throw new Error('no sizing for this. Consider adding a catchall to the end, in which you specify no maximum width');
                }
                i += 1;
              }
              return prime(comp, parent, isHoriz, broadOrigin, longOrigin, broadSpan, longSpan);
            case TileContent:
              tl = _this.boxTile(component, parent, isHoriz, broadOrigin, longOrigin, broadSpan, longSpan);
              _this.container.appendChild(tl.tray);
              tl.opening();
              return tl;
          }
        };
      })(this);
      listeners = ['resize', 'mousemove', 'mousedown', 'mouseup', 'keydown', 'keyup'];
      this.listeners = [];
      listeners.forEach((function(_this) {
        return function(name) {
          var cb;
          cb = function() {
            return Mount.prototype[name].apply(_this, arguments);
          };
          _this.listeners.push({
            name: name,
            callback: cb
          });
          return window.addEventListener(name, cb, false);
        };
      })(this));
      this.prevMouseX = 0;
      this.prevMouseY = 0;
      this.tileBeingResized = null;
      this.resizationCordinal = null;
      this.selectionAllowed = true;
      this.middleBtnDown = false;
      this.rootLine = prime(rootLineExpression, null, false, 0, 0, this.container.offsetWidth, this.container.offsetHeight);
      for (_i = 0, _len = preferenceResizings.length; _i < _len; _i++) {
        _ref = preferenceResizings[_i], tile = _ref.tile, x = _ref.x, y = _ref.y;
        tbroad = tile.isHorizontal ? y : x;
        tlong = tile.isHorizontal ? x : y;
        if (tbroad) {
          tile.tryMoveBroadForthBoundary(tbroad - tile.broadSpan);
        }
        if (tlong) {
          tile.tryMoveLongForthBoundary(tlong - tile.longSpan);
        }
      }
    }

    Mount.prototype.generateNullContent = function() {
      var nelinner;
      nelinner = document.createElement('div');
      nelinner.classList.add('tilingjs_default_tile_inner');
      nelinner.style.backgroundColor = this.shadegen.takeColor();
      return content(nelinner);
    };

    Mount.prototype.dragOperationInProgress = function() {
      return !!this.tileBeingResized || !!this.liftedTile;
    };

    Mount.prototype.mousemove = function(ev) {
      var relx, rely, rx, ry, tb, tile;
      relx = ev.pageX - this.prevMouseX;
      rely = ev.pageY - this.prevMouseY;
      this.prevMouseX = ev.pageX;
      this.prevMouseY = ev.pageY;
      if (this.tileBeingResized) {
        this.resizeTile(this.tileBeingResized, this.resizationCordinal, relx, rely);
      }
      if (this.middleBtnDown && !this.dragOperationInProgress()) {
        tile = this.tileUnderMouse();
        if (tile) {
          tb = elBounds(tile.tray);
          rx = this.prevMouseX - tb.x;
          ry = this.prevMouseY - tb.y;
          if (tb.w / 3 < rx && rx < tb.w / 3 * 2 && tb.h / 3 < ry && ry < tb.h / 3 * 2) {
            return this.liftTile(tile);
          } else {
            return this.startResize(tile, ordForVars(ry > tb.h / 2, rx > tb.w / 2));
          }
        }
      }
    };

    Mount.prototype.mouseup = function(ev) {
      this.stopResize();
      this.stopShiftingTile();
      if (ev.button === 1) {
        return this.middleBtnDown = false;
      }
    };

    Mount.prototype.mousedown = function(ev) {
      var whatIsMoused;
      if (this.ctrlHeld) {
        if (ev.button === 0) {
          whatIsMoused = this.tileUnderMouse();
          if (whatIsMoused) {
            this.liftTile(whatIsMoused);
          }
          ev.preventDefault();
          ev.stopPropagation();
        } else if (ev.button === 2) {
          this.startResizing();
          ev.preventDefault();
          return false;
        }
      }
      if (this.dragOperationInProgress()) {
        ev.stopPropagation();
        return ev.preventDefault();
      } else if (ev.button === 1) {
        return this.middleBtnDown = true;
      }
    };

    Mount.prototype.keydown = function(ev) {
      switch (ev.keyCode) {
        case 17:
          return this.ctrlHeld = true;
        case 18:
          return this.altHeld = true;
        case 67:
          if (ev.altKey && !(ev.shiftKey || ev.ctrlKey || ev.metaKey)) {
            return this.createSignal();
          }
          break;
        case 66:
          if (ev.altKey && !(ev.shiftKey || ev.ctrlKey || ev.metaKey)) {
            return this.deleteSignal();
          }
      }
    };

    Mount.prototype.keyup = function(ev) {
      switch (ev.keyCode) {
        case 17:
          this.ctrlHeld = false;
          this.stopResize();
          return this.stopShiftingTile();
        case 18:
          this.altHeld = false;
          return this.stopShiftingTile();
        case 88:
          return this.stopShiftingTile();
      }
    };

    Mount.prototype.deleteSignal = function(ev) {
      var whatIsMoused;
      whatIsMoused = this.tileUnderMouse();
      if (whatIsMoused) {
        return this.deleteTile(whatIsMoused);
      }
    };

    Mount.prototype.createSignal = function() {
      return this.addAt(this.defaultContentGenerator(), this.prevMouseX, this.prevMouseY);
    };

    Mount.prototype.startResizing = function() {
      var ep, whatIsMoused;
      whatIsMoused = this.tileUnderMouse();
      if (whatIsMoused) {
        ep = elBounds(whatIsMoused.tray);
        this.resizationCordinal = ordinalFor(this.prevMouseX - ep.x, this.prevMouseY - ep.y, whatIsMoused.tray.clientWidth, whatIsMoused.tray.clientHeight);
        return this.startResize(whatIsMoused, this.resizationCordinal);
      }
    };

    Mount.prototype.stopShiftingTile = function() {
      var whatIsMoused, wimpos;
      if (this.liftedTile) {
        whatIsMoused = this.tileUnderMouse();
        if (whatIsMoused) {
          wimpos = elBounds(whatIsMoused.tray);
          return this.dropTile(whatIsMoused, cardinalFor(this.prevMouseX - wimpos.x, this.prevMouseY - wimpos.y, whatIsMoused.tray.clientWidth, whatIsMoused.tray.clientHeight));
        } else {
          return this.releaseLiftedTile();
        }
      }
    };

    Mount.prototype.tileUnderMouse = function() {
      var cop;
      cop = elBounds(this.container);
      return this.seek(this.prevMouseX - cop.x, this.prevMouseY - cop.y);
    };

    Mount.prototype.boxTile = function(content, parent, isHorizontal, broadOrigin, longOrigin, broadSpan, longSpan) {
      var box, tray;
      tray = document.createElement('div');
      tray.classList.add('tilingjs_tray');
      tray.style.backgroundColor = this.shadegen.takeShade();
      box = new Tile(content, tray, parent, isHorizontal, broadOrigin, longOrigin, broadSpan, longSpan);
      tray.addEventListener('mouseover', (function(_this) {
        return function(ev) {
          return _this.tileMouseIsOver = box;
        };
      })(this));
      return box;
    };

    Mount.prototype.detach = function() {
      var binding, _i, _len, _ref, _results;
      _ref = this.listeners;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        binding = _ref[_i];
        _results.push(window.removeEventListener(binding.name, binding.cb));
      }
      return _results;
    };

    removeLiftingmask = function(tile) {
      var elist, _results;
      elist = tile.tray.getElementsByClassName('tilingjs_liftingmask');
      _results = [];
      while (elist.length > 0) {
        _results.push(removeEl(elist[0]));
      }
      return _results;
    };

    Mount.prototype.releaseLiftedTile = function() {
      if (this.liftedTile) {
        removeLiftingmask(this.liftedTile);
        return this.liftedTile = null;
      }
    };

    Mount.prototype.liftTile = function(tile) {
      var liftingmask;
      this.liftedTile = tile;
      liftingmask = document.createElement('div');
      liftingmask.classList.add('tilingjs_liftingmask');
      return tile.tray.appendChild(liftingmask);
    };

    Mount.prototype.dropTile = function(target, cardinal) {
      var orientation, tcom, ti, upa;
      if (this.liftedTile) {
        removeLiftingmask(this.liftedTile);
        if (this.liftedTile !== target) {
          upa = this.liftedTile.content;
          tcom = target.parent.components;
          ti = tcom.indexOf(target);
          if (tcom.length > ti + 1 && tcom[ti + 1] === this.liftedTile) {
            orientation = target.parent.isHorizontal;
            if ((cardIsH(cardinal)) === orientation) {
              cardinal = cardForVars(orientation, false);
            }
          } else if (ti > 0 && tcom[ti - 1] === this.liftedTile) {
            orientation = target.parent.isHorizontal;
            if ((cardIsH(cardinal)) === orientation) {
              cardinal = cardForVars(orientation, true);
            }
          }
          this.removeTile(this.liftedTile);
          this.insertOver(target, upa, cardinal);
        }
        return this.liftedTile = null;
      }
    };

    Mount.prototype.resize = function(ev) {
      var nb, nh, nl, nw;
      nw = this.container.clientWidth;
      nh = this.container.clientHeight;
      nb = (this.rootLine.isHorizontal ? nh : nw) - this.rootLine.broadSpan;
      nl = (this.rootLine.isHorizontal ? nw : nh) - this.rootLine.longSpan;
      this.rootLine.scaleLongForth(nl);
      this.rootLine.scaleBroadForth(nb);
      return this.rootLine.forAllTiles(function(tile) {
        return tile.resized();
      });
    };

    Mount.prototype.resizeTile = function(tile, cornordinal, relx, rely) {
      var xish, yish;
      xish = tile.isHorizontal ? 'Long' : 'Broad';
      yish = tile.isHorizontal ? 'Broad' : 'Long';
      return forCardinalComponentsOfCordinal(cornordinal, function() {
        return tile['tryMove' + yish + 'RearBoundary'](rely);
      }, function() {
        return tile['tryMove' + xish + 'ForthBoundary'](relx);
      }, function() {
        return tile['tryMove' + yish + 'ForthBoundary'](rely);
      }, function() {
        return tile['tryMove' + xish + 'RearBoundary'](relx);
      });
    };

    Mount.prototype.removeTile = function(tile) {
      var oldControl, removeFrom;
      oldControl = tile.content;
      removeFrom = (function(_this) {
        return function(ancestor, tracing) {
          var pi, replaceTracing;
          if (ancestor.components.length === 1) {
            if (ancestor.parent) {
              return removeFrom(ancestor.parent, ancestor);
            } else {
              replaceTracing = function(tr) {
                if (tr.constructor === Tile) {
                  return tr.replaceContent(_this.defaultContentGenerator());
                } else {
                  return replaceTracing(tr.components[0]);
                }
              };
              return replaceTracing(tracing);
            }
          } else {
            pi = ancestor.components.indexOf(tracing);
            ancestor.components.splice(pi, 1);
            if (pi < ancestor.components.length) {
              ancestor.components[pi].justMoveBroadRear(-tracing.broadSpan);
            } else {
              ancestor.components[pi - 1].justMoveBroadForth(tracing.broadSpan);
            }
            tile.tray.classList.add('tilingjs_animation');
            return destructiveFade(tile.tray);
          }
        };
      })(this);
      removeFrom(tile.parent, tile);
      return oldControl;
    };

    Mount.prototype.deleteTile = function(tile) {
      var oldControl;
      oldControl = this.removeTile(tile);
      return oldControl.onClose();
    };

    Mount.prototype.stopResize = function() {
      this.tileBeingResized = null;
      return this.resizationCordinal = null;
    };

    Mount.prototype.startResize = function(tile, cordinal) {
      this.tileBeingResized = tile;
      return this.resizationCordinal = cordinal;
    };

    Mount.prototype.animateRect = function(cardinal, color, left, top, right, bottom) {
      var dspan, fromBottomRight, fromItsSide, fromOrigin, g, gopp, inlineDim, lateralsDim, ogs, r, self;
      r = document.createElement('div');
      r.classList.add('tilingjs_animation');
      r.style['background-color'] = color;
      ogs = [top, bottom, left, right];
      self = this;
      fromOrigin = function(g) {
        return ogs[g] + 'px';
      };
      fromBottomRight = function(g) {
        return (self.container[orientationKeys[(g >> 1) ^ 1].clientSpan] - ogs[g]) + 'px';
      };
      fromItsSide = function(g) {
        if (cardIsForward(g)) {
          return fromBottomRight(g);
        } else {
          return fromOrigin(g);
        }
      };
      inlineDim = cardIsH(cardinal);
      lateralsDim = !inlineDim;
      g = cardForVars(lateralsDim, false);
      r.style[cardSide[g]] = fromOrigin(g);
      g = cardForVars(lateralsDim, true);
      r.style[cardSide[g]] = fromBottomRight(g);
      gopp = cardOpposite(cardinal);
      r.style[cardSide[gopp]] = fromItsSide(gopp);
      dspan = keysForCard(gopp).span;
      r.style[dspan] = '0px';
      prependChild(this.container, r);
      yeildThen(function() {
        return r.style[dspan] = Math.abs(ogs[gopp] - ogs[cardinal]) + 'px';
      });
      return afterAnim(function() {
        return destructiveFade(r);
      });
    };

    Mount.prototype.seek = function(offx, offy) {
      var ob, ol;
      ob = this.rootLine.isHorizontal ? offy : offx;
      ol = this.rootLine.isHorizontal ? offx : offy;
      return this.rootLine.seekProper(ob, ol);
    };

    Mount.prototype.addAt = function(newContent, ox, oy) {
      var r;
      return r = this.insert(newContent, ox, oy, function() {
        return newContent.onOpen();
      });
    };

    Mount.prototype.insert = function(newContent, offx, offy, animationEndCallback) {
      var cop, direction, elp, target;
      cop = elBounds(this.container);
      target = this.seek(offx - cop.x, offy - cop.y);
      if (target) {
        elp = elBounds(target.tray);
        direction = cardinalFor(offx - elp.x, offy - elp.y, target.tray.clientWidth, target.tray.clientHeight);
        return this.insertOver(target, newContent, direction, animationEndCallback);
      } else {
        return null;
      }
    };

    Mount.prototype.insertOver = function(parent, content, cardinal, animationEndCallback) {
      var dirIsForward, dirIsHorizontal, fadecb, gopp, newLine, newTile, newTilesPart, ori, otherOri, parentsPart, parpar, partray, precedentTileIndex;
      partray = parent.tray;
      gopp = cardOpposite(cardinal);
      fadecb = this.animateRect(gopp, content.el.style['background-color'] || 'rgb(255,255,255)', gopp === 2 ? partray.offsetLeft + (partray.clientWidth >> 1) : partray.offsetLeft, gopp === 0 ? partray.offsetTop + (partray.clientHeight >> 1) : partray.offsetTop, gopp === 3 ? partray.offsetLeft + (partray.clientWidth >> 1) : partray.offsetLeft + partray.clientWidth, gopp === 1 ? partray.offsetTop + (partray.clientHeight >> 1) : partray.offsetTop + partray.clientHeight);
      dirIsHorizontal = cardIsH(cardinal);
      dirIsForward = cardIsForward(cardinal);
      ori = orientationKeys[+(!dirIsHorizontal)];
      otherOri = orientationKeys[+dirIsHorizontal];
      parentsPart = Math.floor(partray[ori.clientSpan] / 2);
      newTilesPart = partray[ori.clientSpan] - parentsPart;
      parpar = parent.parent;
      precedentTileIndex = parpar.components.indexOf(parent);
      newTile = null;
      if (dirIsHorizontal === parpar.isHorizontal) {
        newTile = this.boxTile(content, parpar, parent.isHorizontal, parent.broadOrigin + parentsPart * dirIsForward, parent.longOrigin, newTilesPart, parent.longSpan);
        afterAnim((function(_this) {
          return function() {
            parent.setBroadSpan(parentsPart);
            if (!dirIsForward) {
              parent.justTranslateBroadBy(newTile.broadSpan);
            }
            parpar.components = insertBefore(parpar.components, precedentTileIndex + dirIsForward, newTile);
            _this.container.appendChild(newTile.tray);
            if (animationEndCallback) {
              return animationEndCallback();
            }
          };
        })(this));
      } else {
        newLine = new Line(parpar, parent.isHorizontal, parent.broadOrigin, parent.longOrigin, parent.broadSpan, parent.longSpan);
        newTile = this.boxTile(content, newLine, !parent.isHorizontal, newLine.longOrigin + dirIsForward * parentsPart, newLine.broadOrigin, newTilesPart, newLine.broadSpan);
        afterAnim((function(_this) {
          return function() {
            parent.parent = newLine;
            parent.isHorizontal = !newLine.isHorizontal;
            parent.setBroadOrigin(newLine.longOrigin + newTilesPart * !dirIsForward);
            parent.setLongOrigin(newLine.broadOrigin);
            parent.setBroadSpan(parentsPart);
            parent.setLongSpan(newLine.broadSpan);
            newLine.components = dirIsForward ? [parent, newTile] : [newTile, parent];
            parpar.components[precedentTileIndex] = newLine;
            _this.container.appendChild(newTile.tray);
            if (animationEndCallback) {
              return animationEndCallback();
            }
          };
        })(this));
      }
      return newTile;
    };

    return Mount;

  })();

  this.TileContent = (function() {
    function TileContent() {}

    TileContent.prototype.onResize = function() {};

    TileContent.prototype.onClose = function() {};

    TileContent.prototype.onOpen = function() {};

    TileContent.prototype.hasUniqueClass = function() {
      return false;
    };

    return TileContent;

  })();

  this.content = function(element) {
    var c;
    c = new TileContent;
    c.el = element;
    return c;
  };

  Component = (function() {
    function Component(parent, isHorizontal, broadOrigin, longOrigin, broadSpan, longSpan) {
      this.parent = parent;
      this.isHorizontal = isHorizontal;
      this.broadOrigin = broadOrigin;
      this.longOrigin = longOrigin;
      this.broadSpan = broadSpan;
      this.longSpan = longSpan;
      this.isHorizontal = this.parent ? !this.parent.isHorizontal : false;
    }

    Component.prototype.ox = function() {
      if (this.isHorizontal) {
        return this.longOrigin;
      } else {
        return this.broadOrigin;
      }
    };

    Component.prototype.oy = function() {
      if (this.isHorizontal) {
        return this.broadOrigin;
      } else {
        return this.longOrigin;
      }
    };

    Component.prototype.w = function() {
      if (this.isHorizontal) {
        return this.longSpan;
      } else {
        return this.broadSpan;
      }
    };

    Component.prototype.h = function() {
      if (this.isHorizontal) {
        return this.broadSpan;
      } else {
        return this.longSpan;
      }
    };

    Component.prototype.canCompressLong = function(amount) {};

    Component.prototype.canCompressBroad = function(amount) {};

    Component.prototype.forAllTiles = function(f) {
      return f(this);
    };

    Component.prototype.scaleLongForth = function(amount) {};

    Component.prototype.scaleLongRear = function(amount) {};

    Component.prototype.scaleBroadForth = function(amount) {};

    Component.prototype.scaleBroadRear = function(amount) {};

    Component.prototype.justTranslateLongBy = function(amount) {};

    Component.prototype.justTranslateBroadBy = function(amount) {};

    Component.prototype.justMoveLongForth = function(amount) {};

    Component.prototype.justMoveBroadForth = function(amount) {};

    Component.prototype.justMoveLongRear = function(amount) {};

    Component.prototype.justMoveBroadRear = function(amount) {};

    Component.prototype.tryMoveLongForthBoundary = function(amount) {};

    Component.prototype.tryMoveBroadForthBoundary = function(amount) {};

    Component.prototype.tryMoveLongRearBoundary = function(amount) {};

    Component.prototype.tryMoveBroadRearBoundary = function(amount) {};

    return Component;

  })();

  Line = (function(_super) {
    __extends(Line, _super);

    function Line() {
      Line.__super__.constructor.apply(this, arguments);
    }

    Line.prototype.seekProper = function(broadC, longC) {
      var com, _i, _len, _ref;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        if (com.broadOrigin <= longC && longC < com.broadOrigin + com.broadSpan && com.longOrigin <= broadC && broadC < com.longOrigin + com.longSpan) {
          return tileOrLine(com, function(tile) {
            return tile;
          }, function(line) {
            return line.seekProper(longC, broadC);
          });
        }
      }
      return null;
    };

    Line.prototype.firstTile = function() {
      return tileOrLine(this.components[0], function(tile) {
        return tile;
      }, function(line) {
        return line.components[0];
      });
    };

    Line.prototype.scaleLongRear = function(amount) {
      this.scaleLong(amount);
      return this.justTranslateLongBy(amount);
    };

    Line.prototype.scaleBroadRear = function(amount) {
      this.scaleBroad(amount);
      return this.justTranslateBroadBy(amount);
    };

    Line.prototype.scaleLongForth = function(amount) {
      return this.scaleLong(amount);
    };

    Line.prototype.scaleBroadForth = function(amount) {
      return this.scaleBroad(amount);
    };

    Line.prototype.scaleLong = function(amount) {
      var amountGiven, com, giving, has, i, totalw, weightings, _i, _j, _ref, _ref1;
      if (amount === 0) {
        return;
      }
      weightings = new Array(this.components.length);
      totalw = 0;
      amountGiven = 0;
      for (i = _i = 0, _ref = this.components.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        com = this.components[i];
        has = com.canCompressBroad(amount);
        has = amount > 0 ? Math.sqrt(has) : has * has;
        weightings[i] = has;
        totalw += has;
      }
      for (i = _j = 0, _ref1 = this.components.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        com = this.components[i];
        if (i === this.components.length - 1) {
          com.scaleBroadForth(amount - amountGiven);
        } else {
          giving = Math.round((weightings[i] / totalw) * amount);
          com.scaleBroadForth(giving);
        }
        com.justTranslateBroadBy(amountGiven);
        amountGiven += giving;
      }
      this.longSpan += amount;
    };

    Line.prototype.scaleBroad = function(amount) {
      var com, _i, _len, _ref;
      if (amount === 0) {
        return;
      }
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        com.scaleLongForth(amount);
      }
      this.broadSpan += amount;
    };

    Line.prototype.closing = function() {
      var comp, _i, _len, _ref, _results;
      _ref = this.components;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comp = _ref[_i];
        _results.push(comp.closing());
      }
      return _results;
    };

    Line.prototype.canCompressLong = function(amount) {
      var acc, com, _i, _len, _ref;
      acc = 0;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        acc += com.canCompressBroad(amount);
        if (acc >= amount) {
          return amount;
        }
      }
      return acc;
    };

    Line.prototype.canCompressBroad = function(amount) {
      var com, min, _i, _len, _ref;
      min = amount;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        min = Math.min(min, com.canCompressLong(amount));
      }
      return min;
    };

    Line.prototype.justTranslateBroadBy = function(amount) {
      var com, _i, _len, _ref, _results;
      this.broadOrigin += amount;
      _ref = this.components;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        _results.push(com.justTranslateLongBy(amount));
      }
      return _results;
    };

    Line.prototype.justTranslateLongBy = function(amount) {
      var com, _i, _len, _ref, _results;
      this.longOrigin += amount;
      _ref = this.components;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        _results.push(com.justTranslateBroadBy(amount));
      }
      return _results;
    };

    Line.prototype.justMoveLongForth = function(amount) {
      return this.shoveBoundary(this.components.length, amount);
    };

    Line.prototype.justMoveLongRear = function(amount) {
      return this.shoveBoundary(0, amount);
    };

    Line.prototype.justMoveBroadForth = function(amount) {
      var com, _i, _len, _ref;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        com.justMoveLongForth(amount);
      }
      return this.broadSpan += amount;
    };

    Line.prototype.justMoveBroadRear = function(amount) {
      var com, _i, _len, _ref;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        com.justMoveLongRear(amount);
      }
      this.broadOrigin += amount;
      return this.broadSpan -= amount;
    };

    Line.prototype.canMoveBoundary = function(n, amount) {
      var i, remaining, _i, _j, _ref;
      if (amount > 0) {
        remaining = amount;
        for (i = _i = n, _ref = this.components.length; n <= _ref ? _i < _ref : _i > _ref; i = n <= _ref ? ++_i : --_i) {
          remaining -= this.components[i].canCompressBroad(remaining);
          if (remaining === 0) {
            return amount;
          }
        }
        return amount - remaining;
      } else {
        remaining = -amount;
        for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
          remaining -= this.components[i].canCompressBroad(remaining);
          if (remaining === 0) {
            return amount;
          }
        }
        return amount + remaining;
      }
    };

    Line.prototype.shoveBoundary = function(n, amount) {
      var canCompressBy, com, remainsToBeSqueezed;
      if (amount === 0) {
        return;
      }
      if (amount > 0) {
        if (n > 0) {
          this.components[n - 1].justMoveBroadForth(amount);
        } else {
          this.longOrigin += amount;
          this.longSpan -= amount;
        }
        remainsToBeSqueezed = amount;
        while (true) {
          if (n === this.components.length) {
            this.longSpan += remainsToBeSqueezed;
            return;
          }
          com = this.components[n];
          canCompressBy = com.canCompressBroad(remainsToBeSqueezed);
          com.justMoveBroadRear(canCompressBy);
          remainsToBeSqueezed -= canCompressBy;
          com.justTranslateBroadBy(remainsToBeSqueezed);
          if (remainsToBeSqueezed === 0) {
            break;
          }
          n += 1;
        }
      } else {
        if (n < this.components.length) {
          this.components[n].justMoveBroadRear(amount);
        } else {
          this.longSpan += amount;
        }
        remainsToBeSqueezed = -amount;
        while (true) {
          if (n === 0) {
            this.longOrigin -= remainsToBeSqueezed;
            this.longSpan += remainsToBeSqueezed;
            return;
          }
          com = this.components[n - 1];
          canCompressBy = com.canCompressBroad(remainsToBeSqueezed);
          com.justMoveBroadForth(-canCompressBy);
          remainsToBeSqueezed -= canCompressBy;
          com.justTranslateBroadBy(-remainsToBeSqueezed);
          if (remainsToBeSqueezed === 0) {
            break;
          }
          n -= 1;
        }
      }
    };

    Line.prototype.tryMoveBoundary = function(n, amount) {
      var internalMovement, parentMovedBy, remaining, ultimatelyMovedBy;
      if (n === 0 || n === this.components.length) {
        if (this.parent) {
          if (n === 0) {
            return this.parent.tryMoveBroadRearBoundary(amount);
          } else {
            return this.parent.tryMoveBroadForthBoundary(amount);
          }
        } else {
          return 0;
        }
      } else {
        internalMovement = this.canMoveBoundary(n, amount);
        if (internalMovement === amount) {
          this.shoveBoundary(n, internalMovement);
          return amount;
        } else {
          remaining = amount - internalMovement;
          if (this.parent) {
            parentMovedBy = remaining > 0 ? this.parent.tryMoveBroadForthBoundary(remaining) : this.parent.tryMoveBroadRearBoundary(remaining);
            ultimatelyMovedBy = internalMovement + parentMovedBy;
            this.shoveBoundary(n, ultimatelyMovedBy);
            return ultimatelyMovedBy;
          } else {
            this.shoveBoundary(n, internalMovement);
            return internalMovement;
          }
        }
      }
    };

    Line.prototype.tryMoveBroadForthBoundary = function(amount) {
      var myIndex;
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        myIndex = this.parent.components.indexOf(this);
        return this.parent.tryMoveBoundary(myIndex + 1, amount);
      } else {
        return 0;
      }
    };

    Line.prototype.tryMoveBroadRearBoundary = function(amount) {
      var myIndex;
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        myIndex = this.parent.components.indexOf(this);
        return this.parent.tryMoveBoundary(myIndex, amount);
      } else {
        return 0;
      }
    };

    Line.prototype.tryMoveLongForthBoundary = function(amount) {
      if (amount === 0) {
        return 0;
      }
      return this.tryMoveBoundary(this.components.length, amount);
    };

    Line.prototype.tryMoveLongRearBoundary = function(amount) {
      if (amount === 0) {
        return 0;
      }
      return this.tryMoveBoundary(0, amount);
    };

    Line.prototype.forAllTiles = function(f) {
      var com, _i, _len, _ref;
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        com = _ref[_i];
        tileOrLine(com, f, function(line) {
          return line.forAllTiles(f);
        });
        return;
      }
    };

    return Line;

  })(Component);

  Tile = (function(_super) {
    __extends(Tile, _super);

    Tile.prototype.closing = function() {
      return this.content.onClose();
    };

    Tile.prototype.opening = function() {
      return this.content.onOpen();
    };

    Tile.prototype.resized = function() {
      return this.content.onResize();
    };

    function Tile(content, tray, parent, isHorizontal, broadOrigin, longOrigin, broadSpan, longSpan, minBroad, minLong) {
      var ori, otherOri;
      this.content = content;
      this.tray = tray;
      this.minBroad = minBroad != null ? minBroad : minimumTileSpan;
      this.minLong = minLong != null ? minLong : minimumTileSpan;
      this.tray.appendChild(this.content.el);
      this.content.tileHolder = this;
      Tile.__super__.constructor.call(this, parent, isHorizontal, broadOrigin, longOrigin, broadSpan, longSpan);
      ori = keysForOrientation(!this.isHorizontal);
      otherOri = keysForOrientation(this.isHorizontal);
      this.tray.style[ori.rear] = this.broadOrigin + 'px';
      this.tray.style[otherOri.rear] = this.longOrigin + 'px';
      this.tray.style[ori.span] = this.broadSpan + 'px';
      this.tray.style[otherOri.span] = this.longSpan + 'px';
    }

    Tile.prototype.replaceContent = function(newContent) {
      var oldContent;
      this.tray.removeChild(this.content.el);
      this.tray.appendChild(newContent.el);
      oldContent = this.content;
      this.content = newContent;
      newContent.tileHolder = this;
      return oldContent;
    };

    Tile.prototype.canCompressLong = function(amount) {
      return Math.min(amount, Math.max(this.longSpan - this.minLong, 0));
    };

    Tile.prototype.canCompressBroad = function(amount) {
      return Math.min(amount, Math.max(this.broadSpan - this.minBroad, 0));
    };

    Tile.prototype.justTranslateBroadBy = function(amount) {
      return this.setBroadOrigin(this.broadOrigin + amount);
    };

    Tile.prototype.justTranslateLongBy = function(amount) {
      return this.setLongOrigin(this.longOrigin + amount);
    };

    Tile.prototype.setLongOrigin = function(longOrigin) {
      var feild, value;
      this.longOrigin = longOrigin;
      feild = keysForOrientation(this.isHorizontal).rear;
      value = this.longOrigin + 'px';
      return this.tray.style[feild] = value;
    };

    Tile.prototype.setLongSpan = function(longSpan) {
      var feild, value;
      this.longSpan = longSpan;
      feild = keysForOrientation(this.isHorizontal).span;
      value = this.longSpan + 'px';
      return this.tray.style[feild] = value;
    };

    Tile.prototype.setBroadOrigin = function(broadOrigin) {
      var feild, value;
      this.broadOrigin = broadOrigin;
      feild = keysForOrientation(!this.isHorizontal).rear;
      value = this.broadOrigin + 'px';
      return this.tray.style[feild] = value;
    };

    Tile.prototype.setBroadSpan = function(broadSpan) {
      var feild, value;
      this.broadSpan = broadSpan;
      feild = keysForOrientation(!this.isHorizontal).span;
      value = this.broadSpan + 'px';
      return this.tray.style[feild] = value;
    };

    Tile.prototype.justMoveLongForth = function(amount) {
      return this.setLongSpan(this.longSpan + amount);
    };

    Tile.prototype.justMoveLongRear = function(amount) {
      this.setLongOrigin(this.longOrigin + amount);
      return this.setLongSpan(this.longSpan - amount);
    };

    Tile.prototype.justMoveBroadForth = function(amount) {
      return this.setBroadSpan(this.broadSpan + amount);
    };

    Tile.prototype.justMoveBroadRear = function(amount) {
      this.setBroadOrigin(this.broadOrigin + amount);
      return this.setBroadSpan(this.broadSpan - amount);
    };

    Tile.prototype.scaleLongForth = function(amount) {
      return this.justMoveLongForth(amount);
    };

    Tile.prototype.scaleBroadForth = function(amount) {
      return this.justMoveBroadForth(amount);
    };

    Tile.prototype.scaleLongRear = function(amount) {
      return this.justMoveLongRear(amount);
    };

    Tile.prototype.scaleBroadRear = function(amount) {
      return this.justMoveBroadRear(amount);
    };

    Tile.prototype.forAllTiles = function(f) {
      return f(this);
    };

    Tile.prototype.tryMoveBroadForthBoundary = function(amount) {
      var myIndex;
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        myIndex = this.parent.components.indexOf(this);
        return this.parent.tryMoveBoundary(myIndex + 1, amount);
      } else {
        return 0;
      }
    };

    Tile.prototype.tryMoveBroadRearBoundary = function(amount) {
      var myIndex;
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        myIndex = this.parent.components.indexOf(this);
        return this.parent.tryMoveBoundary(myIndex, amount);
      } else {
        return 0;
      }
    };

    Tile.prototype.tryMoveLongForthBoundary = function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        return this.parent.tryMoveBroadForthBoundary(amount);
      } else {
        return 0;
      }
    };

    Tile.prototype.tryMoveLongRearBoundary = function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (this.parent) {
        return this.parent.tryMoveBroadRearBoundary(amount);
      } else {
        return 0;
      }
    };

    return Tile;

  })(Component);

}).call(this);
